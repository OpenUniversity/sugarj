module Control.Arrow.Syntax.Desugar where

import org.sugarj.languages.Haskell

import Meta.Concrete.Haskell
import Control.Arrow.Syntax.Concrete

import Control.Arrow.Syntax.Command
import Control.Arrow.Syntax.Statement


desugarings
  desugar-arrow

rules
  desugar-arrow :
    ArrProcedure(pat, cmd) ->
    |[ arr (\$pat -> $(<tuple> pat-vars))
       >>> $(<desugar-arrow(|pat-vars)> cmd) ]|
  where <free-pat-vars> pat => pat-vars


  desugar-arrow(|vars) :
    ArrFirst(f, e) ->
    |[ arr (\$(<tuple-pat> vars) -> $e) >>> $f ]|

  desugar-arrow(|vars) :
    ArrHigher(f, e) ->
    |[ arr (\$(<tuple-pat> vars) -> ($f, $e)) >>> app ]|

  desugar-arrow(|vars) :
    ArrIf(e, c1, c2) ->
    |[ arr (\$(<tuple-pat> vars) -> 
            if $e 
              then Left $(<tuple> vars)
              else Right $(<tuple> vars))
       >>> ($(<desugar-arrow(|vars)> c1) ||| $(<desugar-arrow(|vars)> c2)) ]|

  desugar-arrow(|vars) :
    ArrLet(decls, c) ->
    |[ arr (\$(<tuple-pat> vars) -> let $*decls in $(<tuple> all-vars))
       >>> $(<desugar-arrow(|all-vars)> c) ]|
  where <free-decls-vars> decls => decls-vars;
        <conc> (vars, decls-vars) => all-vars

  desugar-arrow(|vars) :
    ArrAbs(p, c) ->
    |[ arr (\($(<tuple-pat> vars), p) -> $(<tuple> all-vars))
       >>> $(<desugar-arrow(|all-vars)> c) ]|
  where <free-pat-vars> p => pat-vars;
        <conc> (vars, pat-vars) => all-vars
        
  desugar-arrow(|vars) :
    ArrAppBin(c, e) ->
    |[ arr (\$(<tuple-pat> vars) -> ($(<tuple> vars), $e))
       >>> $(<desugar-arrow(|vars)> c) ]|

  desugar-arrow(|vars) :
    ArrForm(e, cs) ->
    <apply-all(|k)> (e, <map(desugar-arrow(|vars))> cs)
  where k := |[ \$(<tuple-pat> vars) -> $(<tuple> vars) ]|

  desugar-arrow(|vars) :
    ArrOpApp(c1, op, c2) ->
    <desugar-arrow(|vars)> ArrForm(BinCon(op), [c1, c2])



  desugar-arrow(|vars) :
    cmd |[ do $c ]| ->
    <desugar-arrow(|vars)> c

  desugar-arrow(|vars) :
    cmd |[ do let $*decls
              $*cs ]| ->
    |[ arr (\$(<tuple-pat> vars) -> let $*decls in $(<tuple> all-vars))
       >>> $(<desugar-arrow(|all-vars)> cmd |[do $*cs]|) ]|
  where <free-decls-vars> decls => decls-vars;
        <conc> (vars, decls-vars) => all-vars

  desugar-arrow(|vars) :
    cmd |[ do $c
              $*cs ]| ->
    |[ arr (\$(<tuple-pat> vars) -> ($(<tuple> vars), $(<tuple> vars)))
       >>> first $(<desugar-arrow(|vars)> c)
       >>> arr snd
       >>> $(<desugar-arrow(|vars)> cmd |[do $*cs]|) ]|

  desugar-arrow(|vars) :
    cmd |[ do $p <- $c
              $*cs ]| ->
    |[ arr (\$(<tuple-pat> vars) -> ($(<tuple> vars), $(<tuple> vars)))
       >>> first $(<desugar-arrow(|vars)> c)
       >>> arr (\($p, $(<tuple-pat> vars)) -> $(<tuple> all-vars))
       >>> $(<desugar-arrow(|all-vars)> cmd |[do $*cs]|) ]|
  where <free-pat-vars> p => pat-vars;
        <conc> (pat-vars, vars) => all-vars

rules
  tuple-pat : [] -> Constr(Unit())
  tuple-pat : [p] -> p
  tuple-pat : [p|ps] -> Tuple(p,ps)

  tuple : [] -> Constr(Unit())
  tuple : [e] -> e
  tuple : [e|es] -> Product(e,es)

  free-pat-vars = collect-all(?Var(_))

  free-decls-vars = 
    collect-all(?Var(_), union, \VarFunLHS(v,_) -> v\)

  apply-all(|k) : (e, []) -> e
  apply-all(|k) :
    (e, [c|cs]) ->
    <apply-all(|k)> (|[$e (arr $k >>> $c)]|, cs) 

