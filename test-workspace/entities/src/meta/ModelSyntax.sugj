package meta;

import org.sugarj.languages.Java;
import org.sugarj.languages.Model;
import org.sugarj.languages.Sdf2;
import org.sugarj.languages.SugarJ;

import meta.Model;
import meta.Syntax;

public transformation ModelSyntax {
  rules
    main = register-model-imports; 
           SugarCompilationUnit(id,id,mapconcat(![<syntaxmodel-to-sugar>] <+ metamodel-to-nothing))
 
    metamodel-to-nothing :
      ModelDec(_, ModelBody(("Metamodel", _))) -> []
    
    syntaxmodel-to-sugar :
      ModelDec(ModelDecHead(mods, name), ModelBody(("Syntax", Id(metamodel), SyntaxDec(prods)))) ->
      SugarDec(SugarDecHead(mods, name), SugarBody([grammar, transformations]))
    where <resolve-model; extract-model(|metamodel)> metamodel => metamodeldec;
          <?ModelDec(_, ModelBody(("Metamodel", <id>)))> metamodeldec => structures;

          <map(prod-to-sdf(|structures))> prods => sdfprods;
          <!grammar-elem(context-free-syntax(<id>))> sdfprods => grammar;

          <mapconcat(![<prod-to-trans(|structures)>] <+ ![])> prods => rulez;
          <!transformation-elem(Rules(<id>))> rulez => transformations 

  rules
    prod-to-sdf(|structures) :
      Production(n, rhs) ->
      prod(<map(exp-to-sdf())> rhs, sort(n), attrs(annos))
    where <![<cons-anno>] <+ ![]> (n, structures) => annos

    exp-to-sdf : Nonterminal(n) -> sort(n)
    exp-to-sdf : Terminal(t) -> lit(t)
    exp-to-sdf : Many(e) -> iter-star(<exp-to-sdf> e)
    exp-to-sdf : Many1(e) -> iter(<exp-to-sdf> e)
    exp-to-sdf : Optional(e) -> opt(<exp-to-sdf> e)
    exp-to-sdf : Labeled(l, e) -> <exp-to-sdf> e
    exp-to-sdf : Alt(e1, e2) -> alt(<exp-to-sdf> e1, <exp-to-sdf> e2)
    exp-to-sdf : Group([]) -> empty()
    exp-to-sdf : Group([e|es]) -> seq(<exp-to-sdf> e, <map(exp-to-sdf)> es)

    cons-anno : (n, structures) -> term(default(appl(unquoted("cons"), [fun(quoted(cons-name))])))
      where <fetch-elem(?Structure(n,_,_))> structures;
            <conc-strings> (n,"__") => cons-name


  desugarings
    ast-for-metamodel
  rules 
    ast-for-metamodel = fail

    prod-to-trans(|structures) : 
      Production(n, rhs) ->
      RDefNoArgs("ast-for-metamodel", rule)
    where
      <fetch-elem(?Structure(n,_,_))> structures => struct;
      <?Structure(_,_,<id>)> struct => attributes;
      <map(?Attribute(<id>,_); !Var(<id>))> attributes => vars;
      <length> attributes => len;
      <debug> (n, len, rhs, [], attributes);
      <attr-extractors(|n, len, rhs, [])> attributes => conds;
      <strat-seq> conds => cond;

      rule := Rule(Var("e__"), NoAnnoList(Op(n,vars)), cond) 

    strat-seq = !(<id>, Id()); foldl(Seq)

    attr-extractors(|n, anum, rhs, used) :
      [] -> []
    attr-extractors(|n, anum, rhs, used) : 
      [Attribute(a,type) | as] -> 
      <debug> [strat | <attr-extractors(|n, anum, rhs, [index|used])> as]
    where
      <not(oncetd(?Labeled(a,_)))> rhs;
      <debug> (Attribute(a, type), n, anum, rhs, used);
      <conc-strings> (n,"__") => auxcons;
      <next-unused-index> (0,used) => index;
      <pattern-for-index> (index,anum) => pattern;
      <attribute-type-coercion> type => type-coercion;
      strat := AM(BA(Seq(Match(NoAnnoList(Op(auxcons, pattern))), type-coercion), Var("e__")), Var(a))
    attr-extractors(|n, anum, rhs, used) : 
      [Attribute(a,type) | as] -> 
      <attr-extractors(|n, anum, rhs, used)> as
    
    next-unused-index(|i) = 
      debug;
      if elem
        then (inc,id); debug(!"inc:"); next-unused-index
        else ?(<id>,_)
      end

    pattern-for-index : (_,0) -> []
    pattern-for-index : (0,n) -> [RootApp(Id()) | <pattern-for-index> (-1,<dec> n)]
    pattern-for-index : (m,n) -> [Wld() | <pattern-for-index> (<dec> m,<dec> n)]

    attribute-type-coercion : AttrReferenceType(_) -> Id()

    type-coerce-list(s) : [] -> []
    type-coerce-list(s) : [x|xs] -> [<s> x|<type-coerce-list(s)> xs]
    type-coerce-list(s) : x -> [<s> x]

    type-coerce-option(s) : None() -> None()
    type-coerce-option(s) : Some(x) -> Some(<s> x)
    type-coerce-option(s) : x -> Some(<s> x)

    type-coerce-pair(s1,s2) : (x,y) -> (<s1> x, <s2> y)
    type-coerce-pair(s1, s2) : _#([x,y]) -> (<s1> x, <s2> y)


  rules
    register-model-imports =
      ?t;
      ?SugarCompilationUnit(_, <id>,_);
      map(try(register-model-import));
      !t

    register-model-import =
      ?TypeImportDec(name);
      path := <import-model-path> name;
      register-model-import(|path)

    register-model-import =
      ?TransImportDec(name, trans, _);
      path := <import-model-path-trans> (<import-model-path> name, trans);
      register-model-import(|path)

    register-model-import(|path) =
      unqualifiedname := <unqualified-name-from-path> path;
      prim("SUGARJ_resolve_model", path) => model;
      // debug(!(unqualifiedname, " -> "); conc-strings);
      rules(resolve-model :+ unqualifiedname -> model)

    unqualified-name-from-path = 
      string-as-chars(reverse; take-until(?'/'); reverse)

    import-model-path : TypeName(Id(name)) -> name
    import-model-path : TypeName(pkg, Id(name)) -> <conc-strings> (<import-model-pkg> pkg, "/", name)

    import-model-pkg : PackageOrTypeName(Id(name)) -> name
    import-model-pkg : PackageOrTypeName(pkg, Id(name)) -> <conc-strings> (<import-model-pkg> pkg, "/", name)

    import-model-path-trans : (name, []) -> name
    import-model-path-trans = !"resolution of transformation-generated models not yet implemented"; error; fail

  rules
    extract-model(|name) =
      ?SugarCompilationUnit(_,_,<id>);
  	  filter(?ModelDec(ModelDecHead(_, Id(name)), _));
      ?[<id>]
}