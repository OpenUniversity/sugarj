package meta;

import org.sugarj.languages.Java;
import org.sugarj.languages.Model;
import org.sugarj.languages.Sdf2;
import org.sugarj.languages.SugarJ;

import meta.Model;
import meta.Syntax;

public transformation ModelSyntax {
  rules
    main = register-model-imports; 
           SugarCompilationUnit(id,id,mapconcat(![<syntaxmodel-to-sugar>] <+ metamodel-to-nothing))
 
    metamodel-to-nothing :
      ModelDec(_, ModelBody(("Metamodel", _))) -> []
    
    syntaxmodel-to-sugar :
      ModelDec(ModelDecHead(mods, name), ModelBody(("Syntax", Id(metamodel), SyntaxDec(prods)))) ->
      SugarDec(SugarDecHead(mods, name), SugarBody([grammar-elem(context-free-syntax(<map(prod-to-sdf(|structures))> prods))]))
    where <resolve-model; extract-model(|metamodel); ?ModelDec(_, ModelBody(("Metamodel", <id>)))> metamodel => structures

    prod-to-sdf(|structures) :
      Production(n, rhs) ->
      prod(<map(exp-to-sdf())> rhs, sort(n), attrs(annos))
    where <![<cons-anno>] <+ ![]> (n, structures) => annos

    exp-to-sdf : Nonterminal(n) -> sort(n)
    exp-to-sdf : Terminal(t) -> lit(t)
    exp-to-sdf : Many(e) -> iter-star(<exp-to-sdf> e)
    exp-to-sdf : Many1(e) -> iter(<exp-to-sdf> e)
    exp-to-sdf : Optional(e) -> opt(<exp-to-sdf> e)
    exp-to-sdf : Labeled(l, e) -> <exp-to-sdf> e
    exp-to-sdf : Alt(e1, e2) -> alt(<exp-to-sdf> e1, <exp-to-sdf> e2)
    exp-to-sdf : Group([]) -> empty()
    exp-to-sdf : Group([e|es]) -> seq(<exp-to-sdf> e, <map(exp-to-sdf)> es)

    cons-anno : (n, structures) -> term(default(appl(unquoted("cons"), [fun(quoted(cons-name))])))
      where <debug(!(<conc-strings>("fetch ", n, " in "))); fetch(?Structure(n,_,_))> structures;
            <conc-strings> (n) => cons-name

  rules
    register-model-imports =
      ?t;
      ?SugarCompilationUnit(_, <id>,_);
      map(try(register-model-import));
      !t

    register-model-import =
      ?TypeImportDec(name);
      path := <import-model-path> name;
      register-model-import(|path)

    register-model-import =
      ?TransImportDec(name, trans, _);
      path := <import-model-path-trans> (<import-model-path> name, trans);
      register-model-import(|path)

    register-model-import(|path) =
      unqualifiedname := <unqualified-name-from-path> path;
      prim("SUGARJ_resolve_model", path) => model;
      // debug(!(unqualifiedname, " -> "); conc-strings);
      rules(resolve-model :+ unqualifiedname -> model)

    unqualified-name-from-path = 
      string-as-chars(reverse; take-until(?'/'); reverse)

    import-model-path : TypeName(Id(name)) -> name
    import-model-path : TypeName(pkg, Id(name)) -> <conc-strings> (<import-model-pkg> pkg, "/", name)

    import-model-pkg : PackageOrTypeName(Id(name)) -> name
    import-model-pkg : PackageOrTypeName(pkg, Id(name)) -> <conc-strings> (<import-model-pkg> pkg, "/", name)

    import-model-path-trans : (name, []) -> name
    import-model-path-trans = !"resolution of transformation-generated models not yet implemented"; error; fail

  rules
    extract-model(|name) =
      ?SugarCompilationUnit(_,_,<id>);
  	  filter(?ModelDec(ModelDecHead(_, Id(name)), _));
      ?[<id>]
}