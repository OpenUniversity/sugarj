package variability;

import variability.FeatureExpressions;
import variability.Model;
import org.sugarj.languages.Java;

public sugar Config { 

 context-free syntax 
  //config declaration
  AnnoOrSugarMod* "config" JavaId "for" JavaId "{" ConfigDeclaration*  "}" -> ToplevelDeclaration {cons("ConfigDecl")}
  "enable" {FeatureName ","}+ ";" -> ConfigDeclaration {cons("FeatureActivation")}
  "disable" {FeatureName ","}+ ";" -> ConfigDeclaration {cons("FeatureDeactivation")}
  "color" FeatureName EditorServiceInt EditorServiceInt EditorServiceInt ";" -> ConfigDeclaration {cons("FeatureColorDefinition")}

 desugarings
    featureconfig2trans      

 rules
    featureconfig2trans :
    ConfigDecl(mods, Id(n), Id(fm), configs)
    -> TransDec(TransDecHead(mods, Id(n)), TransBody(rulez))
    where 
    <map(featureconfig2rules)> configs => rulez1;
    <map(feature-requirements2rules(|fm))> configs => rulez2;
    <conc> ([Rules([ SDefNoArgs("main", CallNoArgs(SVar("eliminate-variability"))) ])] , rulez1, rulez2) => rulez
    
   featureconfig2rules :
       FeatureActivation(fnames)
       -> Rules(<map(featurename2rule-enabled)> fnames)
       
   featureconfig2rules :
       FeatureDeactivation(fnames)
       -> Rules(<map(featurename2rule-disabled)> fnames)
       
   featurename2rule-enabled :
    FeatureName(Id(n))
    -> SDefNoArgs("feature-enabled", Match(NoAnnoList(Str(n)))) 
       
   featurename2rule-disabled :
    FeatureName(Id(n))
    -> SDefNoArgs("feature-disabled", Match(NoAnnoList(Str(n)))) 
  
   feature-requirements2rules(|fm) =
     (?FeatureActivation(<id>) <+ ![]);
     !Rules(<mapconcat(feature-requirement2rules <+ ![])>)

   feature-requirement2rules :
     FeatureName(Id(n)) ->
     rulez
   where <feature-requirements> n => required;
         <map(feature-literal2rule)> required => rulez

   feature-literal2rule :
     PositiveFeatureLiteral(FeatureName(Id(name))) ->
     SDefNoArgs("feature-enabled", Match(NoAnnoList(Str(name))))

   feature-literal2rule :
     NegativeFeatureLiteral(FeatureName(Id(name))) ->
     SDefNoArgs("feature-disabled", Match(NoAnnoList(Str(name))))

  rules 
    no-variability :
      ModelDec(ModelDecHead(mods, name), ModelBody( ("VariableStructure", structure) ))
      -> structure
      where <not(oncetd(?OptionalNode(_,_)))> structure
      

    eliminate-variability = topdown(try(configure-node)); 
                            SugarCompilationUnit(id,try(filter(not(?VariabilityHole))),map(try(no-variability)));
                            topdown(try(filter(not(?VariabilityHole))))

    

  rules 
    configure-node : 
     OptionalNode(e, s) -> s
      where <is-condition-enabled> e
     
    configure-node :
     OptionalNode(e, s) -> VariabilityHole
      where <is-condition-disabled> e
      
    configure-node :
     VariableNode(e, s1, s2) -> s1
      where <is-condition-enabled> e
      
    configure-node :
     VariableNode(e, s1, s2) -> s2
      where <is-condition-disabled> e

  rules
    is-condition-enabled :
      e@FeatureName(Id(n)) -> e 
      where <feature-enabled> n;
            <not(feature-disabled)> n

    is-condition-enabled :
      n@FeatureExprNot(e) -> n 
      where <is-condition-disabled> e

    is-condition-enabled :
      a@FeatureExprAnd(e1, e2) -> a 
      where <is-condition-enabled> e1;
            <is-condition-enabled> e2

    is-condition-enabled :
      o@FeatureExprOr(e1, e2) -> o 
      where <is-condition-enabled> e1

    is-condition-enabled :
      o@FeatureExprOr(e1, e2) -> o 
      where <is-condition-enabled> e2
      
  rules
    is-condition-disabled :
      e@FeatureName(Id(n)) -> e 
      where <feature-disabled> n;
            <not(feature-enabled)> n      

    is-condition-disabled :
      o@FeatureExprOr(e1, e2) -> o
      where <is-condition-disabled> e1;
            <is-condition-disabled> e2 

    is-condition-disabled :
      o@FeatureExprAnd(e1, e2) -> o
      where <is-condition-disabled> e1

    is-condition-disabled :
      o@FeatureExprAnd(e1, e2) -> o
      where <is-condition-disabled> e2

    is-condition-disabled :
      n@FeatureExprNot(e) -> n 
      where <is-condition-enabled> e

    feature-enabled = fail
    
    feature-disabled = fail     

     
     signature
      constructors 
       VariabilityHole : VariabilityHole
       OptionalNode : FeatureExpr * Expr -> Expr
       VariableNode : FeatureExpr * Expr * Expr -> Expr
}