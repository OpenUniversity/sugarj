package variability;

import variability.FeatureExpressions;
import variability.Model;
import org.sugarj.languages.Java;

public sugar Config { 

 context-free syntax 
  //config declaration
  AnnoOrSugarMod* "config" JavaId "for" JavaId "{" ConfigDeclaration*  "}" -> ToplevelDeclaration {cons("ConfigDecl")}
  "enable" {FeatureName ","}+ ";" -> ConfigDeclaration {cons("FeatureActivation")}
  "disable" {FeatureName ","}+ ";" -> ConfigDeclaration {cons("FeatureDeactivation")}
  "color" FeatureName EditorServiceInt EditorServiceInt EditorServiceInt ";" -> ConfigDeclaration {cons("FeatureColorDefinition")}

 desugarings
    featureconfig2trans      

 rules
    featureconfig2trans :
    ConfigDecl(mods, Id(n), Id(fm), configs)
    -> TransDec(TransDecHead(mods, Id(n)), TransBody([Rules([main-rule | rulez])]))
    where 
      <compute-feature-config> configs => (enabled, disabled);
      <(map(feature-enabled2rule), map(feature-disabled2rule)); conc> (enabled, disabled) => rulez;
      main-rule := SDefNoArgs("main", CallNoArgs(SVar("eliminate-variability")))
    
   feature-enabled2rule = !SDefNoArgs("feature-enabled", Match(NoAnnoList(Str(<id>))))
   feature-disabled2rule = !SDefNoArgs("feature-disabled", Match(NoAnnoList(Str(<id>))))

  rules
    compute-feature-config = ?configs;
      <filter(?FeatureActivation(<collect-all(?FeatureName(Id(<id>)))>)); concat> configs => enabled;
      <filter(?FeatureDeactivation(<collect-all(?FeatureName(Id(<id>)))>)); concat> configs => disabled;
      <feature-config-closure(|[])> (enabled, disabled)

    feature-config-closure(|done) : ([],dis) -> ([],dis)
    feature-config-closure(|done) :
      ([en|ens],dis) ->
      <feature-config-closure(|done)> (ens,dis)
      where <elem> (en,done)
    feature-config-closure(|done) :
      ([en|ens],dis) ->
      ([en|<conc> (new-ens, ens')], <conc> (new-dis, dis'))
      where
        <not(elem)> (en,done);
        <feature-config-closure(|[en|done])> (ens,dis) => (ens',dis');
        <feature-requirements <+ ![]> en => required;
        <filter(?PositiveFeatureLiteral(FeatureName(Id(<id>))))> required => new-ens;
        <filter(?NegativeFeatureLiteral(FeatureName(Id(<id>))))> required => new-dis      

  rules 
    no-variability :
      ModelDec(ModelDecHead(mods, name), ModelBody( ("VariableStructure", structure) ))
      -> structure
      where <not(oncetd(?OptionalNode(_,_)))> structure
      

    eliminate-variability = topdown(try(configure-node)); 
                            SugarCompilationUnit(id,try(filter(not(?VariabilityHole))),map(try(no-variability)));
                            topdown(try(filter(not(?VariabilityHole))))

    

  rules 
    configure-node : 
     OptionalNode(e, s) -> s
      where <is-condition-enabled> e
     
    configure-node :
     OptionalNode(e, s) -> VariabilityHole
      where <is-condition-disabled> e
      
    configure-node :
     VariableNode(e, s1, s2) -> s1
      where <is-condition-enabled> e
      
    configure-node :
     VariableNode(e, s1, s2) -> s2
      where <is-condition-disabled> e

  rules
    is-condition-enabled :
      e@FeatureName(Id(n)) -> e 
      where <feature-enabled> n;
            <not(feature-disabled)> n

    is-condition-enabled :
      n@FeatureExprNot(e) -> n 
      where <is-condition-disabled> e

    is-condition-enabled :
      a@FeatureExprAnd(e1, e2) -> a 
      where <is-condition-enabled> e1;
            <is-condition-enabled> e2

    is-condition-enabled :
      o@FeatureExprOr(e1, e2) -> o 
      where <is-condition-enabled> e1

    is-condition-enabled :
      o@FeatureExprOr(e1, e2) -> o 
      where <is-condition-enabled> e2
      
  rules
    is-condition-disabled :
      e@FeatureName(Id(n)) -> e 
      where <feature-disabled> n;
            <not(feature-enabled)> n      

    is-condition-disabled :
      o@FeatureExprOr(e1, e2) -> o
      where <is-condition-disabled> e1;
            <is-condition-disabled> e2 

    is-condition-disabled :
      o@FeatureExprAnd(e1, e2) -> o
      where <is-condition-disabled> e1

    is-condition-disabled :
      o@FeatureExprAnd(e1, e2) -> o
      where <is-condition-disabled> e2

    is-condition-disabled :
      n@FeatureExprNot(e) -> n 
      where <is-condition-enabled> e

    feature-enabled = fail
    
    feature-disabled = fail     


  rules
    constraint-error =
      ?ConfigDecl(_,_,Id(fm),<id>);
      where(<featuremodel-names> fm => names);
      where(collect-all(constraint-feature-configuration(|names)) => undeclared);
      where(conflicting-features => conflicts);
      <conc> (undeclared, conflicts)
      

    constraint-feature-configuration(|names) :
      fname@FeatureName(Id(n)) -> (fname, <conc-strings> ("Undeclared feature name ", n, "."))
    where <not(elem)> (n,names)

    conflicting-features =
      compute-feature-config;
      isect;
      map(!(<id>, <conc-strings> ("Configuration conflict for feature ",<id>, ".")))

    constraint-note =
      ?decl@ConfigDecl(_,_,Id(fm),<id>);
      compute-feature-config;
      !(decl, ["Enabled features: ", <Fst; intersperse(|",")>, ". Disabled features: ", <Snd; intersperse(|",")>, "."])

    intersperse(|s) : [] -> []
    intersperse(|s) : [x] -> [x]
    intersperse(|s) : [x|y] -> [x,s| <intersperse(|s)> y]

  signature
    constructors 
       VariabilityHole : VariabilityHole
       OptionalNode : FeatureExpr * Expr -> Expr
       VariableNode : FeatureExpr * Expr * Expr -> Expr
}