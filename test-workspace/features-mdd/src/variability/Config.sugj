package variability;

import org.sugarj.languages.Java;
import variability.Java;

public sugar Config { 
	
 context-free syntax	
  //config declaration
  AnnoOrSugarMod* "config" JavaId "for" JavaId "{" ConfigDeclaration*  "}" -> ToplevelDeclaration {cons("ConfigDecl")}
  "enable" {FeatureName ","}+ ";" -> ConfigDeclaration {cons("FeatureActivation")}
  "disable" {FeatureName ","}+ ";" -> ConfigDeclaration {cons("FeatureDeactivation")}
  "color" FeatureName EditorServiceInt EditorServiceInt EditorServiceInt ";" -> ConfigDeclaration {cons("FeatureColorDefinition")}

 desugarings
	featureconfig2trans      

 rules
  	featureconfig2trans : 
  		ConfigDecl(mods, Id(n), Id(fm), configs)
  		-> TransDec(TransDecHead(mods, Id(n)), TransBody(concRulez))
  		where 
  		<map(featureconfig2rules)> configs => rulez;
  		<conc> ([ Rules([SDefNoArgs("main", Call(SVar("oncetd"), [CallNoArgs(SVar("model-to-java"))]))]) ], rulez) => concRulez
  		
  	featureconfig2rules :
  	    FeatureActivation(fnames)
  	    -> Rules(<map(featurename2rule-enabled)> fnames)
  	    
  	featureconfig2rules :
  	    FeatureDeactivation(fnames)
  	    -> Rules(<map(featurename2rule-disabled)> fnames)
  	    
  	featurename2rule-enabled :
  		FeatureName(Id(n))
  		-> SDefNoArgs("feature-enabled", Match(NoAnnoList(Str(n))))	
  	    
  	featurename2rule-disabled :
  		FeatureName(Id(n))
  		-> SDefNoArgs("feature-disabled", Match(NoAnnoList(Str(n))))	
  
  	featureconfig2trans = fail
  		
    model-to-java : 
      ModelDec(ModelDecHead(mods, name), ModelBody(body))
      -> ClassDec(ClassDecHead(mods, name, None, None, None), configuredBody)
      where  
  	  <topdown(cond-stm <+ cond-methods <+ cond-type <+ id)> body => configuredBody 
 
 	model-to-java = fail
    

  rules
    cond-stm :
      ConditionalStatement(e, s) -> s
       where <eval-condition> e

    cond-stm :
      ConditionalStatement(e, s) -> Empty 
       where <not(eval-condition)> e

    filter-method :
      ConditionalMethod(e, m) -> m
       where <eval-condition> e

    filter-method :
      m -> m
      where <not(?ConditionalMethod(_,_))> m

    cond-methods :
      list -> <filter(filter-method)> list

    cond-type :
      ConditionalType(e, t) -> t
       where <eval-condition> e

    cond-type :
      ConditionalType(e, t) -> [] 
       where <not(eval-condition)> e

    eval-condition :
      e@FeatureName(Id(n)) -> e 
      where <feature-enabled> n
      
    feature-enabled = fail

    eval-condition :
      n@FeatureExprNot(e) -> n 
      where <not(eval-condition)> e

    eval-condition :
      a@FeatureExprAnd(e1, e2) -> a 
      where <eval-condition> e1;
            <eval-condition> e2

    eval-condition :
      o@FeatureExprOr(e1, e2) -> o 
      where <eval-condition> e1

    eval-condition :
      o@FeatureExprOr(e1, e2) -> o 
      where <eval-condition> e2
}