package variability;

import concretesyntax.Stratego;
import concretesyntax.EditorServices;
import org.sugarj.languages.Java;

import variability.FeatureExpressions;

public sugar Model {

 context-free syntax
   //feature model
   AnnoOrSugarMod* "featuremodel" JavaId FeatureModelBody -> ToplevelDeclaration{cons("FMDecl")}
   "{" FeatureDeclaration* "}" -> FeatureModelBody {cons("FMBody")}
   "feature" FeatureName FeatureDependencies? ";" -> FeatureDeclaration {cons("FeatureDecl")}
   "requires" {FeatureLiteral ","}* -> FeatureDependencies
   FeatureName -> FeatureLiteral {cons("PositiveFeatureLiteral")}
   "not" FeatureName -> FeatureLiteral {cons("NegativeFeatureLiteral")}
	
 desugarings
   featuremodel

 rules
   featuremodel : 
     FMDecl(mods, Id(n), FMBody(decls))
     -> 
     [SugarDec(SugarDecHead(mods, Id(n)), SugarBody([transformation-elem(rulesblock) | <map(!transformation-elem(<id>))> rulesblocks])),
      EditorServicesDec(EditorServicesDecHead(mods, Id(n)), EditorServicesBody(services))]
     where 
       <featuredecl2sugar(|n)> decls => rulesblock;
       <filter(feature-requirements2rules)> decls => rulesblocks;

       <map(featuredecl2service)> decls => services

  featuredecl2sugar(|n) :
    decls
    ->
    |[ rules featuremodel-names : string~n -> term~names ]|
    where
      <get-decl-names; map(!NoAnnoList(Str(<id>))); !NoAnnoList(List(<id>))> decls => names
  featuremodel-names = fail

  feature-requirements2rules :
    FeatureDecl(FeatureName(Id(n)), Some(lits))
    ->
    |[ rules feature-requirements : string~n -> term~(<trm-explode> lits) ]|
  feature-requirements = fail

  featuredecl2service :
     FeatureDecl(FeatureName(Id(n)), _)
     ->
     |[  completions
           completion template : FeatureName = string~n
     ]|
    
    get-decl-names = map(?FeatureDecl(FeatureName(Id(<id>)), _))
}