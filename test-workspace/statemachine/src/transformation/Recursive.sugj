package transformation;

import transformation.Renaming;

public transformation Recursive {
rules
  main =
    ?(model, model-path, trans-path);
    !(model-path, trans-path);
    prim("SUGARJ_rename_main_args") => (old-name, new-name);
    where(!SDefNoArgs(new-name, Call(SVar("recursively-transform"), [Id(), Call(SVar("try"), [CallNoArgs(SVar(old-name))])])) => new-main);
    !model;
    SugarCompilationUnit(
      id,
      ensure-import(|TypeImportDec(TypeName(PackageOrTypeName(Id("transformation")), Id("Recursive")))),
      map(SugarDec(id, SugarBody(!([transformation-elem(Rules([new-main]))], <id>); conc))));
    prim("SUGARJ_compile", model-path, trans-path)

  recursively-transform(model-predicate, trans) = ?(model, model-path, trans-path); 
    {| Renamings, Stack: 
         rules ( Renamings := [] 
                 Stack := [model-path]);
         !model;
         (where(model-predicate) < trans + id) => generated;
         recursively-transform(model-predicate, trans | trans-path);
         compile-renamed(model-predicate | model-path, trans-path)
    |}

  recursively-transform(model-predicate, trans | trans-path) =
    topdown(try(where(
      {pkgs, name, model-path, model, generated, seen-before, new-renaming:
        get-imported-model(model-predicate) => (pkgs, name, model-path, model);
        where(!(pkgs, name, (<conc-strings> (name, <name-suffix> trans-path))) => new-renaming);
        rules( Renamings := [ new-renaming | <Renamings>] );

        not(is-circular-import(|model-path));
        rules( Stack := [ model-path | <Stack> ] );

        <trans> model => generated;

        tryfinally(
          {| Renamings:
            rules ( Renamings := [new-renaming] );
            recursively-transform(model-predicate, trans | trans-path);
            compile-renamed(model-predicate | model-path, trans-path)
          |},
          rules( Stack := <Stack; Tl> ))
      })))

  compile-renamed(model-predicate | model-path, trans-path) =
    apply-renamings(|<Renamings>);
    if has-circular-import(model-predicate)
      then prim("SUGARJ_write", model-path, trans-path)
      else prim("SUGARJ_compile", model-path, trans-path)
    end

  has-circular-import(model-predicate) =
    where(oncetd(is-circular-import(model-predicate)))

  is-circular-import(model-predicate) =
    get-imported-model(model-predicate) => (pkgs, name, model-path, model);
    is-circular-import(|model-path)
  
  is-circular-import(|model-path) =
    <elem> (model-path,<Stack>)

  get-imported-model(predicate) =
    ?TypeImportDec(<id>);
    import-model-path => (pkgs, name);
    <build-path> (pkgs, name) => path;
    prim("SUGARJ_resolve_model") => model;
    where(predicate);
    !(pkgs, name, path, model)

  ensure-import(|imp) = !(<id>, [imp]); union

  conforms-to-metamodel(|meta-model) =
    where(collect-one(?ModelDecHead(_, _, meta-model)))

  tryfinally(s, final) = s < final + (final; fail)
}

