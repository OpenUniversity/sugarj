package statemachine;

import template.Unquote;
import template.Shorthands;
import template.InlineShorthands;
import template.Foreach;
import template.UnquoteEnum;
import template.LocalStrategies;

import statemachine.Language;
import org.sugarj.languages.Java;

public template ToJava {
  $$event-as-class : Event(name) -> > public static class $name implements Event { } <
  $$all-events-as-classes = collect-all(event-as-class)
  $$transition-premise : Transition(NamedEvent(name),_) -> >e == Event.$name<
  $$transition-consequence : Transition(_, state) -> [ >return State.$state;< ]

  $pkg = collect-one(?PackageDec(_,<id>))
  $classname = collect-one(?ModelDecHead(_,<id>))

  package $pkg;

  import java.lang.IllegalArgumentException;

  public class $classname {
    public static interface Event {}
    $*{all-events-as-classes}
    

    public enum State {
      $for(State(name, transitions) in collect-all(?State(_,_))) {
         $name {
           public State step(Event e) {
             $for(t in !transitions) {
               if (${<transition-premise> t}) {
                 $*{<transition-consequence> t}
               }
             }

             throw new IllegalArgumentException("Unexpected event " + e);
           }
         }
      };

      public abstract State step(Event e);
    }

    private State state = State.${collect-one(?InitialState(<id>))};

    public State step(Event e) {
      state = state.step(e);
      return state;
    }

    public State run(Event[] es) {
      for (Event e : es)
        step(e);
      return state;
    }

    public State currentState() {
      return state;
    }
  }
}