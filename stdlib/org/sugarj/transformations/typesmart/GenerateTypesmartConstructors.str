module org/sugarj/transformations/typesmart/GenerateTypesmartConstructors

imports org/sugarj/transformations/Analyze
        org/sugarj/languages/Sdf2
        org/sugarj/languages/Stratego
        org/sugarj/stdlib/StdTrans
        org/sugarj/transformations/GenerateSignatures

rules
  main = io-wrap(
    ![1,2,3]
    //   parse def file
    // ; collect and concat bodies of all SDF modules in a single list
    // ; apply gen-syntax-constructors to this list
    // ; put resulting constructors in a single Stratego module
  )        

rules
  put-syntax-sort(|sort) =
    (where(get-analysis-data-annotation) <+ init-analysis-data-annotation);
    put-anno(|"syntax-sort", sort);
    where(get-syntax-sort)
  get-syntax-sort =
    get-anno(|"syntax-sort")
  has-syntax-sort =
    where(get-syntax-sort)
  
rules
  gen-syntax-constructors =
    filter( ?context-free-syntax(<id>)
           + ?context-free-priorities(<collect-all(?prod(_,_,_))>)
           + ?syntax(<id>));
    where(map(!context-free-syntax(<id>); 
              gen-signature-from-grammar;
              !transformation-elem(<id>))
          => sig-list);
    map(
      filter(gen-syntax-constructors-prod + gen-subsort-of-inject);
      !transformation-elem(Rules(<id>)));
    ?smart-cons-list;
    <conc> (sig-list, smart-cons-list)

  gen-syntax-constructors-prod :
    prod(lhs, rhs, attrs(as)) ->
    strat
  where
      <filter(?term(default(fun(quoted(<id>)))) 
            + ?term(default(appl(unquoted("cons"), [fun(quoted(<id>))]))))> as => [cons-with-quotes]
    ; <unquote(?'"')> cons-with-quotes => cons
    ; <conc-strings> ("smart-", cons) => smart-cons
   
    ; <filter(get-symbol-sort)> lhs => arg-sorts
    ; <get-symbol-sort> rhs => res-sort
    
    ; <make-arg-list(|1)> arg-sorts => args
    ; <zip; map(gen-arg-check(|cons))> (args, arg-sorts) => arg-checks
    
    ; <map(!Var(<id>)); !NoAnnoList(List(<id>))> args => args-term
    ; !BA(Prim("\"SUGARJ_unsafe_build\"", [NoAnnoList(Str(cons))]), args-term) => build
    ; !CallT(SVar("put-syntax-sort"), [], [<trm-explode> res-sort]) => put-res
    ; <conc; foldr(!Id(), \ (x,y) -> Seq(x,y) \)> (arg-checks, [build, put-res]) => body
    
    ; <map(!DefaultVarDec(<id>))> args => var-decs
    ; !SDefT(smart-cons, [], var-decs, body) => strat
  
  gen-subsort-of-inject :
    prod ->
    strat
  where
      <?prod(lhs, rhs, attrs(as)) + ?prod(lhs, rhs, no-attrs()); ![]=>as> prod 
    ; <filter(?term(default(fun(quoted(<id>)))) 
            + ?term(default(appl(unquoted("cons"), [fun(quoted(<id>))]))))> as => []
    ; <filter(get-symbol-sort)> lhs => [arg-sort]
    ; <get-symbol-sort> rhs => res-sort
    ; body := CallT(SVar("is-subsort-of-inject"), []
                  , [ <trm-explode> arg-sort, <trm-explode> res-sort])

    ; !SDefT("is-subtype-of", [], [], body) => strat

  gen-arg-check(|cons) :
    (arg, arg-sort) -> 
    Where(BA(LChoice(
        CallNoArgs(SVar("has-sort"))
      , Seq(CallT(SVar("log-mismatching-sort-error"), [], [<trm-explode> cons])
        , Fail()))
    , NoAnnoList(Tuple([arg, <trm-explode> arg-sort]))))
  
  log-mismatching-sort-error =
    (not(get-syntax-sort), id);
    debug(!"Constructor argument lacks sort annotation: ")
  
  log-mismatching-sort-error(|cons) =
    (get-syntax-sort, id);
    ?(was, exp);
    where(<conc-strings> 
            ("Mismatching argument sort for constructor '", cons, "'.",
             " Was ", <write-to-string> was, ",",
             " expected ", <write-to-string> exp) => s);
    <debug(!s)> "."
  
  make-arg-list(|n) :
    [] -> []
  make-arg-list(|n) :
    [_|rest] -> [arg| <make-arg-list(|<inc> n)> rest]
    where <conc-strings> ("arg", <int-to-string> n) => arg
  
  has-sort = ?([], Sort("List", _))
  has-sort = ?(None(), Sort("Option", _))
  has-sort = ?(Some(x), Sort("Option", [xsort]));
             !(x, xsort);
             has-sort
  has-sort = (get-syntax-sort, id); is-subsort-of
  
  is-subsort-of = is-subsort-of-refl
  is-subsort-of-refl = structurally-equal
  is-subsort-of-inject(|arg-sort,res-sort) =
      ?(sub-sort,sup-sort)
    ; <structurally-equal> (sub-sort, arg-sort) 
    ; ( <structurally-equal> (sup-sort, res-sort)
     <+ <is-subsort-of> (res-sort, sup-sort)) 
  
//////////////////////////
// meta explode

signature
  constructors
    ToTerm       : a -> Term
    FromTerm     : Term -> a
    ToBuild      : a -> Strategy
    FromApp      : Strategy -> a
    ToStrategy   : a -> Strategy
    FromStrategy : Strategy -> a
    WithAnno     : a * ListTerm -> a
    meta-var     : String -> a
    meta-listvar : String -> a
    Cong         : String * List(Strategy) -> Strategy
    Ins          : Term -> Term
    ManglePrefix : String * Var -> Term
    MangleSuffix : Var * String -> Term


signature
  constructors
    AsFix   : Option
    appl    : Term * List(Term) -> Term
    prod    : List(Term) * Term * Term -> Term
    cf      : Term -> Term
    opt     : Term -> Term
    layout  : Term
    ConsAux : a * List(a) -> List(a)


rules

  Clean :
    Op("Wld", []) -> Wld()

  Clean :
    Op(i, []) -> NoAnnoList(Int(<int-to-string> i))
    where <is-int> i


strategies
  meta-explode =
    MetaExplode ; topdown(try(Clean))

  MetaExplode =
    alltd(
      Anno(
        ?ToTerm(<pretrm-explode>)
      , MetaExplode
      )
      + AnnoList(
          ?ToTerm(<pretrm-explode>)
        , MetaExplode
        )
      + NoAnnoList(?ToTerm(<pretrm-explode>))
      + ?ToTerm(<trm-explode>)
      + ?ToMetaExpr(<trm-explode>)
      + ?ToMetaListExpr(<trm-explode>)
      + ?ToBuild(<!Build(<trm-explode>)>)
      + ?ToStrategy(<str-explode>)
    )

  trm-explode =
    ToTermToTerm
    <+ TrmMetaVar
    <+ LstMetaVar
    <+ TrmFromTerm
    <+ TrmFromApp
    <+ TrmFromStr
    <+ TrmAnno
    <+ ConcAssocR ; trm-explode
    <+ ConcCons ; trm-explode
    <+ ConcNil ; trm-explode
    <+ !NoAnnoList(
          <TrmInt
           <+ TrmStr
           <+ TrmConc
           <+ TrmNil
           <+ TrmCons
           <+ TrmOp>
        )

  pretrm-explode =
    ToTermToTerm
    <+ TrmMetaVar
    <+ LstMetaVar
    <+ TrmInt
    <+ TrmStr
    <+ TrmFromTerm
    <+ TrmFromApp
    <+ TrmFromStr
    <+ TrmAnno ; fatal-err(|"anno in anno")
    <+ ConcAssocR ; pretrm-explode
    <+ ConcCons ; pretrm-explode
    <+ ConcNil ; pretrm-explode
    <+ TrmConc
    <+ TrmNil
    <+ TrmCons
    <+ TrmOp

  ToTermToTerm =
    ?ToTerm(t) ; quoted-trm-explode

  quoted-trm-explode =
    QuotedOp

  QuotedOp :
    op#(ts) -> Op(op, <map(quoted-trm-explode)> ts)

  TrmOp :
    op#(ts) -> Op(op, <map(trm-explode)> ts)

  TrmMetaVar :
    meta-var(x) -> Var(x)

  LstMetaVar :
    meta-listvar(x) -> Var(y)
    where if <(explode-string ; last)> x => '*' then
            !ListVar(x)
          else
            !x
          end => y

  TrmInt =
    !Int(<is-int ; int-to-string>)

  TrmStr =
    !Str(<is-string>)

  TrmFromTerm =
    ?FromTerm(<MetaExplode>)

  TrmFromTerm =
    ?FromMetaExpr(<MetaExplode>)

  TrmFromTerm =
    ?FromMetaListExpr(<MetaExplode>)

  TrmFromStr =
    ?FromStrategy(<MetaExplode>)

  TrmFromApp =
    ?FromApp(<!RootApp(<MetaExplode>)>)

  TrmAnno :
    WithAnno(t1, t2) -> Anno(t1', t2')
    where <(trm-explode ; try(?NoAnnoList(<id>)))> t1 => t1'
          ; (<is-list> t2 <+ ![t2])
          ; foldr(
              !NoAnnoList(Op("Nil", []))
            , !NoAnnoList(
                 Op(
                   "Cons"
                 , [<Fst>, <Snd>]
                 )
               )
            , MetaExplode
            )
          ; try(?NoAnnoList(<id>)) => t2'

  TrmNil :
    [] -> Op("Nil", [])

  TrmCons :
    [x|xs] -> Op(
                "Cons"
              , [<trm-explode> x, <trm-explode> xs]
              )

  TrmCons :
    ConsAux(x, xs) -> Op(
                        "Cons"
                      , [<trm-explode> x, <trm-explode> xs]
                      )

  ConcAssocR :
    Conc(Conc(t1, t2), t3) -> "Conc"#([t1, "Conc"#([t2, t3])])

  ConcCons :
    Conc([t1|t2], t3) -> ConsAux(
                           t1
                         , "Conc"#([t2, t3])
                         )

  ConcCons :
    Conc(ConsAux(t1, t2), t3) -> ConsAux(
                                   t1
                                 , "Conc"#([t2, t3])
                                 )

  ConcNil :
    Conc([], t) -> t

  ConcNil :
    Conc(t, []) -> t

  TrmConc :
    Conc(t1, t2) -> Op(
                      "Conc"
                    , [<trm-explode> t1, <trm-explode> t2]
                    )

  TrmFromMangle :
    ManglePrefix(x, y) -> App(
                            Call(SVar("conc-strings"), [])
                          , Tuple(
                              [Str(x), Var(y)]
                            )
                          )

  TrmFromMangle :
    MangleSuffix(x, y) -> App(
                            Call(SVar("conc-strings"), [])
                          , Tuple(
                              [Var(x), Str(y)]
                            )
                          )

  str-explode =
    \ meta-var(x) -> Match(Var(x)) \
    <+ TrmFromTerm
    <+ TrmFromStr
    <+ ?FromApp(<MetaExplode>)
    <+ \ [] -> Cong("Nil", []) \
    <+ \ [t|ts] -> Cong(
                     "Cons"
                   , [<str-explode> t, <str-explode> ts]
                   ) \
    <+ is-string
       ; !Match(NoAnnoList(Str(<id>)))
    <+ \ op#(ts) -> Cong(op, <map(str-explode)> ts) \


signature
  constructors
    ToMetaExpr       : a -> b
    ToMetaListExpr   : a -> b
    FromMetaExpr     : a -> StrategoTerm
    FromMetaListExpr : a -> StrategoTerm