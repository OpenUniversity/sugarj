module org/sugarj/transformations/typesmart/GenerateTypesmartConstructors

imports org/sugarj/transformations/Analyze
        org/sugarj/languages/Sdf2
        org/sugarj/languages/Stratego
        org/sugarj/transformations/GenerateSignatures

imports libstratego-lib
        libstratego-sdf
        libstrc

rules
  main = io-stream-wrap(typesmart-options,
      ?(inp,out)
      ; if OutputModule then
		      <parse-sdf-definition-stream> inp
		    ; collect-all(?exports(<id>) + ?hiddens(<id>))
		    ; mapconcat(flatten-grammar)
		    ; gen-syntax-constructors
		    ; !Module(<OutputModule>, <id>)
		    ; pp-stratego-stream(|out)
		    else
		      !""
		    ; fatal-err(|"Need to specify an output module using the '-m' option.")
		    end
  )        

  debug-pp-stratego =
  	bottomup(try( not(is-string)
  	            ; not(is-list)
  	            ; not(pp-stratego-string)
  	            ; debug(!"cannot pp stratego: ")))

rules
  typesmart-options = 
    ArgOption(
      "-m"
    , rules(OutputModule := <id>)
    , !"-m <module>      Module name of the output Stratego module"
    )

rules
  flatten-grammar =
      try(
         \ empty-grammar() -> [] \
      <+ \ conc-grammars(g1,g2) -> <conc> (<flatten-grammar> g1, <flatten-grammar> g2) \
      <+ \ g -> [g] \
      )

rules
  put-syntax-sort(|sort) =
    (where(get-analysis-data-annotation) <+ init-analysis-data-annotation);
    put-anno(|"syntax-sort", sort);
    where(get-syntax-sort)
  get-syntax-sort =
    get-anno(|"syntax-sort")
  has-syntax-sort =
    where(get-syntax-sort)
  
rules
  gen-syntax-constructors =
    filter( ?context-free-syntax(<id>)
           + ?context-free-priorities(<collect-all(?prod(_,_,_))>)
           + ?syntax(<id>));
    where( concat
         ; !context-free-syntax(<id>)
    	   ; gen-signature-from-grammar
          => sig-list);
    map(
      filter(gen-syntax-constructors-prod + gen-subsort-of-inject);
      !Rules(<id>));
    ?smart-cons-list;
    <conc> ([sig-list], smart-cons-list)

  gen-syntax-constructors-prod :
    prod(lhs, rhs, attrs(as)) ->
    strat
  where
      <filter(get-cons-attribute)> as => [cons]
    ; <conc-strings> ("smart-", cons) => smart-cons
   
    ; <filter(get-symbol-sort)> lhs => arg-sorts
    ; <get-symbol-sort> rhs => res-sort
    
    ; <make-arg-list(|1)> arg-sorts => args
    ; <zip; map(gen-arg-check(|cons))> (args, arg-sorts) => arg-checks
    
    ; <map(!Var(<id>)); !NoAnnoList(List(<id>))> args => args-term
    ; !BA(Prim("\"SUGARJ_unsafe_build\"", [NoAnnoList(Str(cons))]), args-term) => build
    ; !CallT(SVar("put-syntax-sort"), [], [<trm-explode> res-sort]) => put-res
    ; <conc; foldr(!Id(), \ (x,y) -> Seq(x,y) \)> (arg-checks, [build, put-res]) => body
    
    ; <map(!DefaultVarDec(<id>))> args => var-decs
    ; !SDefT(smart-cons, [], var-decs, body) => strat
  
  gen-subsort-of-inject :
    prod ->
    strat
  where
      <?prod(lhs, rhs, attrs(as)) + ?prod(lhs, rhs, no-attrs()); ![]=>as> prod 
    ; <filter(get-cons-attribute)> as => []
    ; <filter(get-symbol-sort)> lhs => [arg-sort]
    ; <get-symbol-sort> rhs => res-sort
    ; body := CallT(SVar("is-subsort-of-inject"), []
                  , [ <trm-explode> arg-sort, <trm-explode> res-sort])

    ; !SDefT("is-subtype-of", [], [], body) => strat

    
  gen-arg-check(|cons) :
    (arg, arg-sort) -> 
    Where(BA(LChoice(
        CallNoArgs(SVar("has-sort"))
      , Seq(CallT(SVar("log-mismatching-sort-error"), [], [<trm-explode> cons])
        , Fail()))
    , NoAnnoList(Tuple([NoAnnoList(Str(arg)), <trm-explode> arg-sort]))))
  
  log-mismatching-sort-error =
    (not(get-syntax-sort), id);
    debug(!"Constructor argument lacks sort annotation: ")
  
  log-mismatching-sort-error(|cons) =
    (get-syntax-sort, id);
    ?(was, exp);
    where(<conc-strings> 
            ("Mismatching argument sort for constructor '", cons, "'.",
             " Was ", <write-to-string> was, ",",
             " expected ", <write-to-string> exp) => s);
    <debug(!s)> "."
  
  make-arg-list(|n) :
    [] -> []
  make-arg-list(|n) :
    [_|rest] -> [arg| <make-arg-list(|<inc> n)> rest]
    where <conc-strings> ("arg", <int-to-string> n) => arg
  
  has-sort = ?([], Sort("List", _))
  has-sort = ?(None(), Sort("Option", _))
  has-sort = ?(Some(x), Sort("Option", [xsort]));
             !(x, xsort);
             has-sort
  has-sort = (get-syntax-sort, id); is-subsort-of
  
  is-subsort-of = is-subsort-of-refl
  is-subsort-of-refl = structurally-equal
  is-subsort-of-inject(|arg-sort,res-sort) =
      ?(sub-sort,sup-sort)
    ; <structurally-equal> (sub-sort, arg-sort) 
    ; ( <structurally-equal> (sup-sort, res-sort)
     <+ <is-subsort-of> (res-sort, sup-sort)) 
