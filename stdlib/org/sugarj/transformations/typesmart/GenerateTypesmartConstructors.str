module org/sugarj/transformations/typesmart/GenerateTypesmartConstructors

imports org/sugarj/transformations/Analyze
        org/sugarj/languages/Sdf2
        org/sugarj/languages/Stratego
        org/sugarj/transformations/GenerateSignatures

imports libstratego-lib
        libstratego-sdf
        libstrc

rules
  main = io-stream-wrap(typesmart-options,
      ?(inp,out)
      ; if OutputModule then
          <parse-sdf-definition-stream> inp
        ; gen-syntax-constructors-from-module
        ; !Module(<OutputModule>,
                  [Imports([ Import("org/sugarj/transformations/typesmart/Runtime")
                           , Import("org/sugarj/languages/Stratego")]) | <id>])
        ; pp-stratego-stream(|out)
        else
          !""
        ; fatal-err(|"Need to specify an output module using the '-m' option.")
        end
  )        

  debug-pp-stratego =
    bottomup(try( not(is-string)
                ; not(is-list)
                ; not(pp-stratego-string)
                ; debug(!"cannot pp stratego: ")))  

rules
  typesmart-options = 
    ArgOption(
      "-m"
    , rules(OutputModule := <id>)
    , !"-m <module>      Module name of the output Stratego module"
    )
  
rules
  gen-syntax-constructors-from-module =
          ?mod
        ; collect-all(?exports(<id>) + ?hiddens(<id>))
        ; mapconcat(flatten-grammar)
        ; gen-syntax-constructors => conses
          
        ; !mod
        ; collect-all(?renamings(<id>))
        ; mapconcat(filter(\ symbol(from,to) -> (from,to) \))
        ; map(gen-renaming-inject) => renamings
        
        ; <conc> (conses, renamings)

  flatten-grammar =
      try(
         \ empty-grammar() -> [] \
      <+ \ conc-grammars(g1,g2) -> <conc> (<flatten-grammar> g1, <flatten-grammar> g2) \
      <+ \ g -> [g] \
      )



rules  
  gen-syntax-constructors =
  	?grammar;
    filter( ?context-free-syntax(<id>)
          + ?context-free-priorities(<collect-all(?prod(_,_,_))>)
          + ?syntax(<id>));
    where( concat
         ; !context-free-syntax(<id>)
         ; gen-signature-from-grammar
          => sig-list);
    concat;
    merge-same-cons-prods-list;
    filter(gen-syntax-constructors-prod + gen-subsort-of-inject);
    !Rules(<id>) => smart-conses;
    
    !grammar;
    filter( ?lexical-syntax(<id>)
          + ?lexical-priorities(<collect-all(?prod(_,_,_))>));
    map(filter(gen-lexical-sort-prod); nub; !Rules(<id>)) => lexical-sort-list;
    <conc> ([sig-list], lexical-sort-list, [smart-conses])

  gen-syntax-constructors-prod :
    prod(lhs, rhs, attrs) ->
    strat
  where
      <find-cons-attribute> attrs => cons
    ; <conc-strings> ("smart-", cons) => smart-cons
   
    ; <filter(get-symbol-sort)> lhs => arg-sorts
    ; <get-symbol-sort> rhs => res-sort
    
    ; <make-arg-list(|1)> arg-sorts => args
    ; <zip; map(gen-arg-check(|cons))> (args, arg-sorts) => arg-checks
    
    ; <map(!Var(<id>)); !NoAnnoList(List(<id>))> args => args-term
    ; !BA(Prim("\"SUGARJ_unsafe_build\"", [NoAnnoList(Str(cons))]), args-term) => build
    ; !CallT(SVar("put-syntax-sort"), [], [<nosmart-trm-explode> res-sort]) => put-res
    ; <conc; foldr(!Id(), \ (x,y) -> Seq(x,y) \)> (arg-checks, [build, put-res]) => body
    
    ; <map(!DefaultVarDec(<id>))> args => var-decs
    ; !SDefT(smart-cons, [], var-decs, body) => strat
  
  gen-subsort-of-inject :
    prod ->
    strat
  where
      <?prod(lhs, rhs, attrs)> prod 
    ; <not(find-cons-attribute)> attrs
    ; <filter(get-symbol-sort)> lhs => [arg-sort]
    ; <get-symbol-sort> rhs => res-sort
    ; body := CallT(SVar("is-subsort-of-inject"), []
                  , [ <nosmart-trm-explode> arg-sort, <nosmart-trm-explode> res-sort])

    ; !SDefT("is-subsort-of-trans", [], [], body) => strat

  gen-renaming-inject :
    (from,to) ->
    strat
  where
      <get-symbol-sort> from => arg-sort
    ; <get-symbol-sort> to => res-sort
    ; body := 
        Seq(
        Seq(
          Where(Assign(Var("renamed"), <nosmart-trm-explode> res-sort)),
          Match(Var("renamed"))),
          <nosmart-trm-explode> arg-sort)
    ; !SDefT("unrename-sort", [], [], body) => strat

  gen-lexical-sort-prod :
    prod(lhs, rhs, _) ->
    strat
  where
      <get-symbol-sort> rhs => res-sort
    ; body := CallT(SVar("equal"), [], [<nosmart-trm-explode> res-sort])
    ; !SDefT("is-lexical-sort", [], [], body) => strat

  gen-arg-check(|cons) :
    (arg, arg-sort) -> 
    Where(BA(LChoice(
        CallNoArgs(SVar("has-sort"))
      , Seq(CallT(SVar("log-mismatching-sort-error"), [], [<nosmart-trm-explode> cons])
        , Fail()))
    , NoAnnoList(Tuple([Var(arg), <nosmart-trm-explode> arg-sort]))))
  
  make-arg-list(|n) :
    [] -> []
  make-arg-list(|n) :
    [_|rest] -> [arg| <make-arg-list(|<inc> n)> rest]
    where <conc-strings> ("arg", <int-to-string> n) => arg

  merge-same-cons-prods =
      ?(prod(lhs1, rhs1, attrs1), prod(lhs2, rhs2, attrs2))
    ; <(find-cons-attribute,find-cons-attribute)> (attrs1, attrs2) => (cons,cons)
    ; <(filter(get-symbol-sort),filter(get-symbol-sort))> (lhs1,lhs2) => (arg-sorts,arg-sorts)
    ; !prod(lhs1, alt(rhs1, rhs2), attrs1)
 
  merge-same-cons-prods-list =
      ?[]
  merge-same-cons-prods-list =
      ?[x|xs]
    ; <filter-split(!(x,<id>); merge-same-cons-prods)> xs => (merged, rest)
    ; <merge-same-cons-prods-list> rest => rest'
    ; <conc> (merged, rest')
    
    
  filter-split(s) =
      ?[]
    ; !([],[])
  filter-split(s) =
      ? [x|xs]
    ; <filter-split(s)> xs => (ok,nok)
    ; if <s> x => x'
        then !([x'|ok],nok)
        else !(ok,[x|nok])
      end

rules
  nosmart-trm-explode =
      nosmart-TrmAnno
      <+ ConcAssocR; nosmart-trm-explode
      <+ ConcCons; nosmart-trm-explode
      <+ ConcNil; nosmart-trm-explode
      <+ !NoAnnoList(<
            TrmInt 
            <+ TrmStr 
      <+ nosmart-TrmConc 
      <+ TrmNil 
      <+ nosmart-TrmCons 
      <+ nosmart-TrmOp
          >)
  
    nosmart-pretrm-explode = 
      TrmInt 
      <+ TrmStr 
      <+ nosmart-TrmAnno; fatal-err(|"anno in anno")
      <+ ConcAssocR; nosmart-pretrm-explode
      <+ ConcCons; nosmart-pretrm-explode
      <+ ConcNil; nosmart-pretrm-explode
      <+ nosmart-TrmConc
      <+ TrmNil 
      <+ nosmart-TrmCons 
      <+ nosmart-TrmOp

    nosmart-TrmAnno : 
      WithAnno(t1, t2) -> Anno(t1', t2')
      where <nosmart-trm-explode; try(?NoAnnoList(<id>))> t1 => t1'
          ; (<is-list>t2 <+ ![t2])
          ; foldr(!NoAnnoList(Op("Nil",[]))
           ,!NoAnnoList(Op("Cons", [<Fst>, <Snd>]))
           , MetaExplode)
          ; try(?NoAnnoList(<id>)) => t2'

    nosmart-TrmConc :
      Conc(t1, t2) -> Op("Conc", [<nosmart-trm-explode>t1, <nosmart-trm-explode>t2])

    nosmart-TrmCons :
      [x | xs] -> 
      Op("Cons",[<nosmart-trm-explode>x, <nosmart-trm-explode> xs])

    nosmart-TrmOp : 
      op#(ts) -> 
      BA(Prim("\"SUGARJ_unsafe_build\"", [NoAnnoList(Str(op))]), <nosmart-trm-explode> ts)
