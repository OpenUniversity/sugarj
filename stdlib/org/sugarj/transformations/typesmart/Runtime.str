module org/sugarj/transformations/typesmart/Runtime

imports org/sugarj/transformations/Analyze
        org/sugarj/languages/Stratego

rules
  put-syntax-sort(|sort) =
    prim("SUGARJ_put_typesmart_sort", sort)
  get-syntax-sort =
    prim("SUGARJ_get_typesmart_sort") 

rules
  has-sort = Swap; debug-analysis(!"has sort? "); fail
  has-sort = ?(xs, Sort("List", [xsort]))
           ; <map(!(<id>, xsort); has-sort)> xs
  has-sort = ?(""#(xs), Sort("Tuple", xsorts))
           ; <equal> (<length> xs, <length> xsorts)
           ; <zip> (xs, xsorts)
           ; map(has-sort)
  has-sort = ?(None(), Sort("Option", _))
  has-sort = ?(Some(x), Sort("Option", [xsort]))
           ; <has-sort> (x, xsort)
  has-sort = ?(x, Sort("Alt", [xsort1, xsort2]))
           ; (<has-sort> (x, xsort1) + <has-sort> (x, xsort2))
  has-sort = ?(x, xsort)
           ; <is-string> x
           ; <is-lexical-sort> xsort
  has-sort = (debug(!"has get syntax sort: ");get-syntax-sort, id); is-subsort-of
  has-sort = Swap; debug-analysis(!"FAIL has sort: "); fail
  
  is-lexical-sort = fail
  
  is-subsort-of = debug-analysis(!"is-subsort-of: "); fail
  is-subsort-of = is-subsort-of-refl
  is-subsort-of-refl = structurally-equal
  is-subsort-of-inject(|arg-sort,res-sort) =
      ?(sub-sort,sup-sort)
    ; (structurally-equal
      <+  <structurally-equal> (sub-sort, arg-sort) 
        ; ( <structurally-equal> (res-sort, sup-sort)
            <+ <is-subsort-of> (res-sort, sup-sort)) )

rules
  log-mismatching-sort-error(|cons) =
    (not(get-syntax-sort), id);
    Swap;
    debug-analysis(<conc-strings> ("Argument of constructor ", cons, " lacks sort annotation, expected: "))
  
  log-mismatching-sort-error(|cons) =
    (get-syntax-sort, id);
    ?(was, exp);
    where(<conc-strings> 
            ("Mismatching argument sort for constructor '", cons, "'.",
             " Was ", <write-to-string> was, ",",
             " expected ", <write-to-string> exp) => s);
    <debug-analysis(!s)> "."
  
