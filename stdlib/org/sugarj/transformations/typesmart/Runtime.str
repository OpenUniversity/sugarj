module org/sugarj/transformations/typesmart/Runtime

imports org/sugarj/transformations/Analyze
        org/sugarj/languages/Stratego
        org/sugarj/stdlib/Common

rules
  // redefined in Stratego
  smart-Some(|arg) =
      <get-syntax-sort> arg => xsort
    ; <prim("SUGARJ_unsafe_build", "Some")> [arg] 
    ; put-syntax-sort(|<prim("SUGARJ_unsafe_build", "Sort")> ["Option", [xsort]])

rules
  put-syntax-sort(|sort) =
    prim("SUGARJ_put_typesmart_sort", sort)
  get-syntax-sort =
    prim("SUGARJ_get_typesmart_sort") 

rules
  // has-sort = Swap; debug(!"has sort? "); fail
  has-sort = ?(xs, Sort("List", [xsort]))
           ; <map(!(<id>, xsort); has-sort)> xs
  has-sort = ?(""#(xs), Sort("Tuple", xsorts))
           ; <equal> (<length> xs, <length> xsorts)
           ; <zip> (xs, xsorts)
           ; map(has-sort)
  has-sort = ?(None(), Sort("Option", _))
  has-sort = ?(Some(x), Sort("Option", [xsort]))
           ; <has-sort> (x, xsort)
  has-sort = ?(x, Sort("Alt", [xsort1, xsort2]))
           ; (<has-sort> (x, xsort1) + <has-sort> (x, xsort2))
  has-sort = ?(x, xsort)
           ; <is-string> x
           ; <is-lexical-sort> xsort
  has-sort = (get-syntax-sort, id); init-subsort-stack; is-subsort-of
  has-sort =
      ?(term, sort)
    // ; <not(get-syntax-sort)> term     // there might be a misleading imploder attachment
    ; <infer-sort> term => inferred
    ; <debug-analysis(!"inferred sort: ")> (inferred, term)
    ; init-subsort-stack
    ; <is-subsort-of> (inferred, sort)
  // has-sort = Swap; debug(!"FAIL has sort: "); fail
  
  is-lexical-sort = fail
  
  // is-subsort-of = debug-analysis(!"is-subsort-of: "); fail
  is-subsort-of =
      ?(Sort("Alt",[sort1, sort2]), sort)
    ; (<is-subsort-of> (sort1, sort) + <is-subsort-of> (sort2, sort))
  is-subsort-of = 
      push-subsort-stack
    ; finally( is-subsort-of-refl <+ is-subsort-unrename <+ is-subsort-of-trans
             , pop-subsort-stack)
  // is-subsort-of = debug-analysis(!"FAIL is-subsort-of: "); fail
  
  init-subsort-stack =
    where(rules ( Subsort-Stack := [] ))
  push-subsort-stack =
      where(
        strip-annos => pair
      ; <not(elem)> (pair, <Subsort-Stack>)
      ; rules( Subsort-Stack := [pair | <Subsort-Stack>] ))
  pop-subsort-stack =
    where(rules( Subsort-Stack := <Subsort-Stack; ?[_|<id>]> ))
  
  is-subsort-of-refl = sort-equal
  is-subsort-unrename = (unrename-sort, try(unrename-sort)); is-subsort-of
  is-subsort-unrename = (id, unrename-sort); is-subsort-of
  is-subsort-of-trans = fail
  unrename-sort = fail
  
  is-subsort-of-inject(|arg-sort,res-sort) =
  	  ?(sub-sort,sup-sort)
      // result to argument
      ; <sort-equal> (sup-sort, res-sort)
      ; where(<try(unrename-sort)> arg-sort => unrenamed-arg-sort)
      // ; <debug-analysis(!"inject: ")> (unrenamed-arg-sort, res-sort) 
      ; <is-subsort-of> (sub-sort, unrenamed-arg-sort)

  sort-equal = structurally-equal
  sort-equal = ?(Sort("List", [EmptyCollection()]), Sort("List", [_]))
  sort-equal = ?(Sort("Option", [EmptyCollection()]), Sort("Option", [_]))

  infer-sort =
      is-list
    ; ?[]
      < <prim("SUGARJ_unsafe_build", "Sort")> ["List", [EmptyCollection()]]
      + ?[x|xs]
      ; <prim("SUGARJ_unsafe_build", "Sort")> ["List", [<get-syntax-sort> x]] => xsort
      ; where(<has-sort> (xs, xsort))
  infer-sort =
      ?None()
      < <prim("SUGARJ_unsafe_build", "Sort")> ["Option", [EmptyCollection()]]
      + ?Some(x)
      ; <prim("SUGARJ_unsafe_build", "Sort")> ["Option", [<get-syntax-sort> x]]
  infer-sort =
    debug(!"infer failed: "); fail

signature constructors
  EmptyCollection : Sdf2Sort

rules
  log-mismatching-sort-error(|cons) =
    (not(get-syntax-sort), id);
    Swap;
    debug(<conc-strings> ("Argument of constructor ", cons, " lacks sort annotation, expected: "))
  
  log-mismatching-sort-error(|cons) =
    (get-syntax-sort, id);
    ?(was, exp);
    where(<conc-strings> 
            ("Mismatching argument sort for constructor '", cons, "'.",
             " Was ", <write-to-string> was, ",",
             " expected ", <write-to-string> exp) => s);
    <debug(!s)> "."
