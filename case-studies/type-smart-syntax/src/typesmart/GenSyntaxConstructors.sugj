package typesmart;

import concretesyntax.Stratego;

public sugar GenSyntaxConstructors {
  desugarings
    gen-syntax-constructors
  
  rules
    gen-syntax-constructors =
      is-list; ?list;
      filter(?grammar-elem(<id>);
             (  ?context-free-syntax(<id>)
              + ?context-free-priorities(<id>)
              + ?syntax(<id>)));
      not(?[]);
      map(
        filter(gen-syntax-constructors-prod + gen-subsort-of-inject);
        !transformation-elem(Rules(<id>)));
      ?smart-cons-list;
      !Locked(<conc> (list, smart-cons-list))
  
    gen-syntax-constructors-prod :
      prod(lhs, rhs, attrs(as)) ->
      strat
    where
	      <filter(?term(default(fun(quoted(<id>)))) 
	            + ?term(default(appl(unquoted("cons"), [fun(quoted(<id>))]))))> as => [cons-with-quotes]
	    ; <unquote(?'"')> cons-with-quotes => cons
	    ; <conc-strings> ("smart-", cons) => smart-cons
	   
	    ; <filter(get-symbol-sort)> lhs => arg-sorts
	    ; <get-symbol-sort> rhs => res-sort
	    
	    ; <make-arg-list(|1)> arg-sorts => args
	    ; <zip; map(gen-arg-check)> (args, arg-sorts) => arg-checks
	    
	    ; <map(!Var(<id>)); !NoAnnoList(List(<id>))> args => args-term
	    ; !stratego-strategy|[ <prim("SUGARJ_unsafe_build", string~cons)> term~args-term ]| => build
	    ; !|[ put-anno(|"syntax-sort", term~<trm-explode>res-sort) ]| => put-res
	    ; <conc; foldr(!Id, \ (x,y) -> Seq(x,y) \)> (arg-checks, [build, put-res]) => body
	    
	    ; <map(!DefaultVarDec(<id>))> args => var-decs
	    ; !SDefT(smart-cons, [], var-decs, body) => strat
    
    gen-subsort-of-inject :
      prod ->
      strat
    where
        <?prod(lhs, rhs, attrs(as)) + ?prod(lhs, rhs, no-attrs); ![]=>as> prod 
      ; <filter(?term(default(fun(quoted(<id>)))) 
              + ?term(default(appl(unquoted("cons"), [fun(quoted(<id>))])))); debug-analysis> as => []
      ; <filter(get-symbol-sort);debug-analysis> lhs => [arg-sort]
      ; <get-symbol-sort;debug-analysis> rhs => res-sort
      ; body := |[ is-subsort-of-inject(|term~<trm-explode>arg-sort,term~<trm-explode>res-sort) ]|
      ; !SDefT("is-subtype-of", [], [], body) => strat

    gen-arg-check :
      (arg, arg-sort) -> |[ where(<has-sort> (id~arg, term~<trm-explode>arg-sort))  ]|
    
    make-arg-list(|n) :
      [] -> []
    make-arg-list(|n) :
      [_|rest] -> [arg| <make-arg-list(|<inc> n)> rest]
      where <conc-strings> ("arg", <int-to-string> n) => arg
    
    has-sort = (get-anno(|"syntax-sort"), id); is-subsort-of
    is-subsort-of = is-subsort-of-refl
    is-subsort-of-refl = structurally-equal
    is-subsort-of-inject(|arg-sort,res-sort) =
        ?(sub-sort,sup-sort)
      ; <structurally-equal> (sub-sort, arg-sort) 
      ; ( <structurally-equal> (sup-sort, res-sort)
       <+ <is-subsort-of> (res-sort, sup-sort)) 
    
}

